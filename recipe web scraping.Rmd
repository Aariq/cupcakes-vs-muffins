---
title: "R Notebook"
output: html_notebook
author: "Eric R. Scott"
---

```{r packages, message=FALSE, warning=FALSE}
library(rvest)
library(purrr)
library(stringr)
library(tidyverse)
library(beepr) #for notification sounds when long functions are done running
```

To Do:

- add a save_rds at some point to prevent having to re-run read_html_slow() so often 
- apple butter gets tagged as "fat" (e.g. 255405)
- summarize by ingredient type so all the fats (eg) get added up
- if units are weird (not handled by unit conversion `case_when()`), it's probably an "other" (e.g. "24 ice cream cones" gets labeled as "milk", but it's really an other.  You can tell becaue "ice" isn't a unit.)


```{r helpers}
#create function to read_html slowly to avoid getting banned
read_html_slow <- function(x, ...){
  output <- read_html(x)
  Sys.sleep(5)
  return(output)
}

read_html_safely <- possibly(read_html_slow, NA)
#testing:
#read_html_slow("http://allrecipes.com/recipe/233538/really-real-strawberry-cupcakes/")
```


# Get links to all cupcake and muffin recipes
allrecipes.com has a tag structure that is easy to navigate.  All the recipes for a category show up, but on several pages.  I didn't bother figuring out how many pages there were programatically, I just looked on the website.
```{r}
#initialize vector
cupcakes_urls <- c()

#This link takes you to page 1 by default
base_url <- "http://allrecipes.com/recipes/377/desserts/cakes/cupcakes/"

for(i in 1:12){ #tested and found there are 12 pages of cupcake recipes
  cupcakes_urls <- c(cupcakes_urls, paste0(base_url, "?page=", i))
}

# map the read_html function to read all the pages at once
cupcakes <- map(cupcakes_urls, read_html_slow)
beep(4)

# extract the recipe links from all the pages
results <- cupcakes %>% map(~html_nodes(.,".fixed-recipe-card__title-link"))
cupcakes_links <- results %>% map(~html_attr(.,"href")) %>% flatten_chr()

# remove NAs
cupcakes_links <- cupcakes_links[!is.na(cupcakes_links)]
head(cupcakes_links)
```
Sweet! (literally) Now we have `r length(cupcakes_links)` cupcake recipes.

# Get links to muffin recipes
```{r}
muffin_urls <- c()
base_url2 <- "https://www.allrecipes.com/recipes/350/bread/quick-bread/muffins/"
for(i in 1:5){ #tested and found there are 5 pages of muffin recipes
  muffin_urls <- c(muffin_urls, paste0(base_url2, "?page=", i))
}

muffins <- map(muffin_urls, read_html_slow)
beep(4)

# extract the recipe links from all the pages
results2 <- muffins %>% map(~html_nodes(.,".fixed-recipe-card__title-link"))
muffin_links <- results2 %>% map(~html_attr(.,"href")) %>% flatten_chr()

# remove NAs
muffin_links <- muffin_links[!is.na(muffin_links)]
head(muffin_links)
```


```{r}
#get random sample of recipe links
n = 26
cupcake_sample <- sample(cupcakes_links, n/2)
muffin_sample <- sample(muffin_links, n/2)
```

```{r eval=FALSE, include=FALSE}
#get ALL recipes!!!
cupcake_sample <- cupcakes_links
muffin_sample <- muffin_links
```


# Scrape recipes!
To figure out if cupcakes are different than muffins, I need to get all the ingredients, categorize them as variables, get all the units the same for each variable across recipes, and exclude frosting or toppings. (I only care if the cake part is different from a muffin, obviously cupcakes are frosted and muffins are not).  I should standardize ingredient amounts by serving size.  Serving size and calorie count are in the same spot in each recipe, so I might as well get those too.

## Read in all the html of all the recipes
```{r read-recipes}
pb <- progress_estimated(length(cupcake_sample)) #makes a progress bar
cupcakes_html <- cupcake_sample %>%
  map(~{
    pb$tick()$print() #updates progress bar
    read_html_safely(.x)
    })

# anyNA(cupcakes_html)
# length(cupcakes_html[is.na(cupcakes_html)])

pb <- progress_estimated(length(muffin_sample))
muffin_html <- muffin_sample %>%
  map(~{
    pb$tick()$print() #updates progress bar
    read_html_safely(.x)
    })
beep(4)
# anyNA(muffin_html)
# length(muffin_html[is.na(muffin_html)])
```

## Filter out any that didn't work
If a recipe didn't get read in, I want to remove that link from `cupcake_sample` and `muffin_sample` because I'll use the same links later on to extract calories and servings, then remove it from `cupcakes_html` and `muffin_html` so that `html_nodes()` works on it.

```{r}
#first the links
# cupcake_sample[is.na(cupcakes_html)]
cupcake_sample <- cupcake_sample[!is.na(cupcakes_html)]
muffin_sample <- muffin_sample[!is.na(muffin_html)]

#then the html
cupcakes_html <- cupcakes_html[!is.na(cupcakes_html)]
muffin_html <- muffin_html[!is.na(muffin_html)]
```


## Extract ingredients and categorize into "parts"
Most cupcake recipes divide the ingredients list with headers that end in a colon, like "Cake:" or "Frosting:".  I can use that to create a variable, `part`, that later will help me filter out toppings and frostings.  I doubt muffins will have "parts" that are useful.  They might be separated into wet and dry ingredients, but those are both part of the muffin.

```{r extract-parts}
cupcakes_ing <- cupcakes_html %>% map(~html_nodes(., ".added")) %>% map(html_text)

cupcakes_ing <- cupcakes_ing %>% map(~ as_tibble(.) %>%
                       mutate(part = str_extract(.$value, ".+:$")) %>% 
                       fill(part) %>% 
                       filter(!str_detect(.$value, ":")) %>% 
                       filter(value != "Add all ingredients to list"))
# head(cupcakes_ing)
```

## Identify cake vs. frosting
Only keep "parts" that have the word "cake" in them for cupcakes.
*What if there are no "parts"?* I think it is safe to assume that if a cupcake recipe has a "part" for some ingredients but not for others, the ingredients without a "part" are the cake.  If a cupcake recipe has no "parts" listed at all, then it should be excluded as it is not safe to assume all ingredients are for the cake (see "problems" below for examples and more discussion).


```{r fill-in-parts}
cupcakes_ing <- cupcakes_ing %>% map(~
  mutate(., part = ifelse(any(!is.na(part)) & is.na(part), "Cake:", part)))
```
Muffins won't have the problem of "parts", but I should still create that column so I can `bind_rows()` later without an issue.

```{r}
muffins_ing <- muffin_html %>% map(~html_nodes(., ".added")) %>% map(html_text)

muffins_ing <- muffins_ing %>% map(~ as_tibble(.) %>%
                       mutate(part = str_extract(.$value, ".+:$")) %>% 
                       fill(part) %>% 
                       filter(!str_detect(.$value, ":")) %>% 
                       filter(value != "Add all ingredients to list"))
```


## Extract calories and serving size
Occasionally a recipe seems to not have calories.  I need to catch these and conver to NA
```{r}
cupcake_calories <- cupcakes_html %>% 
  map(~html_nodes(., ".calorie-count span:nth-child(1)")) %>%
  map(html_text) %>%
  map(., ~ifelse(identical(., character(0)), NA, .)) #replaces character(0) with NA

#cupcake_calories[[166]]

cupcake_servings <- cupcakes_html %>% 
  map(~html_nodes(., ".subtext")) %>%
  map(html_text) %>% 
  map(~str_extract(.,"(?<=yields\\s)\\d+")) %>% 
  map(., ~ifelse(identical(., character(0)), NA, .)) #replaces character(0) with NA

cupcakes_ing <- map2(cupcakes_ing, cupcake_servings, ~mutate(.x, servings = as.integer(.y)))
cupcakes_ing <- map2(cupcakes_ing, cupcake_calories, ~mutate(.x, calories = as.integer(.y)))

muffin_calories <- muffin_html %>% 
  map(~html_nodes(., ".calorie-count span:nth-child(1)")) %>%
  map(html_text) %>% 
  map(., ~ifelse(identical(., character(0)), NA, .)) #replaces character(0) with NA

muffin_servings <- muffin_html %>% 
  map(~html_nodes(., ".subtext")) %>%
  map(html_text) %>% 
  map(~str_extract(.,"(?<=yields\\s)\\d+")) %>% 
  map(., ~ifelse(identical(., character(0)), NA, .)) #replaces character(0) with NA

muffins_ing <- map2(muffins_ing, muffin_servings, ~mutate(.x, servings = as.integer(.y)))
muffins_ing <- map2(muffins_ing, muffin_calories, ~mutate(.x, calories = as.integer(.y)))
```


# Flatten
Extract recipe ID number and `bind_rows()` to create one data frame for all recipes in `cupcake_sample` and one for all recipes in `muffin_sample`. Then `bind_rows()` of muffins and cupcakes using "muffin" or "cupcake" as the id.

```{r}
#add names to list of data frames
names(cupcakes_ing) <- str_extract(cupcake_sample, "(?<=/)\\d+")
names(muffins_ing) <- str_extract(muffin_sample, "(?<=/)\\d+")
cupcakes_df <- cupcakes_ing %>% bind_rows(.id = "Recipe ID")
muffins_df <- muffins_ing %>% bind_rows(.id = "Recipe ID")
```
**Filter out frosting here!**  Now is the chance to get rid of any cupcake recipe ingredients with no "part" listed or a part that is not "cake"
```{r}
cupcakes_df <- cupcakes_df %>% filter(str_detect(part, "cake"))
```

```{r bind-all-recipes}
#add "cupcake" or "muffin" as name
recipes <- bind_rows(cupcakes_df, muffins_df, .id = "Type") %>% mutate(Type = ifelse(Type == 1, "cupcake", "muffin"))
recipes

#write_rds(recipes, "recipes_raw.rds")
```

# Extract variables
I'll use regular expressions to try to extract the amount and units.  Then in the same `mutate()` call I'll try to categorize ingredients into discrete variables.

```{r}
str_detect_any <- function(string, pattern){
  map_lgl(string, ~stri_detect_regex(., pattern) %>% any(.))
}

fruits <- c("\\w*apple", "\\w*berr(y|ies)", "raisin", "lemon", "banana",
            "orange", "pear", "peach", "rhubarb", "plum", "cherry", "fruit")

nuts <- c("\\w*nut", "almond", "pecan", "seed")

veggies <- c("carrot", "pumpkin", "potato", "zucchini", "corn")

spices <- c("cinnamon", "nutmeg", "clove", "ginger", "spice", "cardomom")
```


```{r}
recipes2 <- recipes %>%  
  mutate(value = tolower(value)) %>% 
  mutate(amount = str_extract(.$value, "^[\\d, /]+"),
         units = str_extract(.$value, "(\\(.+\\)|[^0-9, /]+)"), #finds either something in parens, or next word
         ingredient = case_when(#sweeteners
                                str_detect(.$value, "sugar")        ~ "sugar",
                                str_detect(.$value, "juice")        ~ "fruit juice",
                                str_detect(.$value, "honey")        ~ "honey",
                                str_detect(.$value, "agave")        ~ "agave",
                                str_detect(.$value, "stevia")       ~ "low-cal sweetener",
                                str_detect(.$value, "splenda")      ~ "low-cal sweetener",
                                str_detect(.$value, "truvia")       ~ "low-cal sweetener",
                                #starches
                                str_detect(.$value, "flour")        ~ "flour",
                                str_detect(.$value, "starch")       ~ "starch",
                                str_detect(.$value, "corn\\s?meal") ~ "cornmeal",
                                str_detect(.$value, "bran")         ~ "bran",
                                str_detect(.$value, "\\boat")       ~ "oats", # oat but not "coated"
                                #dairy
                                str_detect(.$value, "buttermilk")   ~ "buttermilk", #snag before butter and milk
                                str_detect(.$value, "milk")         ~ "milk",
                                str_detect(.$value, "cream cheese") ~ "cream cheese",
                                str_detect(.$value, "sour cream")   ~ "sour cream",
                                str_detect(.$value, "tartar")       ~ "other", #snag cream of tartar before cream
                                str_detect(.$value, "\\bcream\\b")  ~ "cream", #not "creamy"
                                str_detect(.$value, "yogurt")       ~ "yogurt",
                                #fats
                                str_detect(.$value, "\\boil\\b")    ~ "oil", #not "boiling"
                                str_detect(.$value, "shortening")   ~ "shortening",
                                str_detect(.$value, "mayonnaise")   ~ "mayonnaise",
                                 #butter has to go at the end, after apple butter and peanut butter are captured
                                #leavening
                                str_detect(.$value, "baking soda")  ~ "baking soda",
                                str_detect(.$value, "baking powder")~ "baking powder",
                                #other
                                str_detect(.$value, "\\bsalt\\b")   ~ "salt", #not "salted" or "unsalted"
                                str_detect(.$value, "water")        ~ "water",
                                str_detect(.$value, "vanilla")      ~ "vanilla",
                                str_detect(.$value, "chocolate")    ~ "chocolate",
                                str_detect(.$value, "cocoa")        ~ "chocolate",
                                str_detect(.$value, "egg")          ~ "eggs",
                                str_detect(.$value, "vinegar")      ~ "vinegar",
                                #spices
                                str_detect_any(.$value, spices)     ~ "spice",
                                #nuts
                                str_detect_any(.$value, nuts)       ~ "nut",
                                #fruit
                                str_detect_any(.$value, fruits)     ~ "fruit",
                                #veggies
                                str_detect_any(.$value, veggies)    ~ "vegetable",
                                #butter
                                str_detect(.$value, "butter")       ~ "butter",
                                TRUE ~ "other"))

recipes2 %>% select(value, ingredient, units, amount, everything())
```

After testing this with several different random samples of cupcake recipes, I'm pretty happy with it. 

Things I've noticed that are wrong/missed:

- "creamy natural peanut butter" is categorized as cream
- coffee
- whiskey(?!?)
- "caramel ice cream topping" is categorized as cream
- tea
- bacon grease
- xanthan gum
- bisquick

# Convert fractions to decimals
The `ammount` column is character class.  I want numeric.

I think one approach would be to turn a space into a "+" then use mutate to do `eval(parse(ammount))`
```{r}
recipes3 <- recipes2 %>% 
  mutate(amount = str_trim(amount)) %>% 
  mutate(dec_amount = str_replace(amount, "\\s", "+")) %>% 
  mutate(dec_amount = sapply(dec_amount, function(x) eval(parse(text=x))))
recipes3 %>% select(amount, dec_amount, everything())
```

# Unit conversions

## Deal with package size
Occasionally an ingredient is like "1 (8 ounce) packet of cream cheese" and my script so far detects "1" as the amount and "(8 ounce)" as the units.  I should deal with this.

**Deal with "oz." and possible decimal points (e.g. "12.5 ounce")** (e.g. 234135)
```{r}
#test <- cupcakes_ing3$units
#str_view_all(test, "\\(.+ (ounce|oz.)")

#test2 <- c("(8 ounce)", "(.68 oz. tube)", "(12.3 ounce)")
#str_view(test2, "\\.?\\d+\\.?\\d*")

# as.numeric(str_extract(test, "\\d+"))*1
recipes3 <- recipes3 %>%
  mutate(dec_amount = ifelse(str_detect(units, "\\(.+ (ounce|oz.)"),
                          as.numeric(str_extract(units, "\\.?\\d+\\.?\\d*")) * dec_amount,
                          dec_amount),
         units = ifelse(str_detect(units, "\\(.+ (ounce|oz.)"), "ounces", units))
```

```{r}
#overwrite original amount column to avoid confusion
recipes4 <- recipes3 %>%
  select(-amount) %>%
  rename(amount = dec_amount) %>% 
  select(Type, ingredient, amount, units, servings, calories, value,`Recipe ID`, part)
```

## Unit conversions
Just for the sake of uniformity, let's put everything in "cups" except eggs.
```{r}
#units we should be able to convert to "cups"
convertable <- c("tablespoon", "teaspoon", "cup", "ounce", "pint", "pinch")

recipes5 <- recipes4 %>% 
  mutate(amount_std = case_when(ingredient == "eggs"            ~ amount,
                                str_detect(units, "cup")        ~ amount,
                                str_detect(units, "pinch")      ~ amount / 768,
                                str_detect(units, "teaspoon")   ~ amount * 0.0208333,
                                str_detect(units, "tablespoon") ~ amount * 0.0625,
                                str_detect(units, "ounce")      ~ amount * 0.125,
                                str_detect(units, "pint")       ~ amount * 2,
                                TRUE                            ~ as.numeric(NA))) %>%
  #change units to cups
  mutate(units_std = case_when(str_detect_any(units, convertable) ~ "cups",
                               ingredient == "eggs"               ~ "eggs",
                               TRUE                               ~ as.character(NA))) %>% 

  select(`Recipe ID`, ingredient, amount, units, amount_std, units_std, everything())

```

# Summarise
Some recipes may have multiple ingredients within an ingredient category.  For example, a recipe might have two kinds of fruit, or it might have 2 eggs plus 2 eggwhites, or two different kinds of oil.  I need to add up those amounts so each variable is only listed once per recipe.

At the same time, I might be able to deal with ingredients with no units in some way.  These are mostly going to be ingredients like "2 apples."  It's not practical to estimate the volume of every one of these ingredients, but it seems "wrong" to ignore them.

I see three options

1. Ignore these ingredients.  Just remove ingredients with an `NA` for `units_std`
2. Remove problem recipes.  Remove recipes with any ingredient that has `NA` for `units_std`
3. **Count these ingredients.**  Instead of adding up actual amounts when summarising, convert the `amount_std` to 1 for all ingredients with `unit_std == NA`.  Then the sum will represent a count rather than a volume.  These ingredients should also be flagged as "unitless" so they can be removed from particular analyses if count data are inappropriate.


```{r}
#set up to "count" unitless ingredients
recipes5b <- recipes5 %>% 
  mutate(ingredient = ifelse(is.na(units_std), "unitless", ingredient),
         amount_std = ifelse(is.na(units_std), 1, amount_std))

recipes_tidy <- recipes5b %>% 
  group_by(Type, `Recipe ID`, ingredient) %>% 
  summarise(amount_sum = sum(amount_std),
            units_std = first(units_std),
            servings = first(servings),
            calories = first(calories),
            value = paste(value, collapse = ";")
  )

recipes_tidy
# recipes_tidy %>% filter(ingredient == "unitless")
```
# Write to RDS
You've done a lot of work.  Save it here
```{r}
write_rds(recipes_tidy, "recipes_tidy.rds")
```



# Notes

Problems:

1. **Recipes without defined "parts"**

Some recipes don't define what ingredients are for the cakes vs. the frosting.  My intention is to exclude frosting ingredients from this analysis, so the safest way to deal with this is to assume that unless it has the word "cake" somewhere in the `part` column, then the ingredient is not for the cake part.

- Some have a "part" for frosting, but not for the cake. (e.g. 261244, 255301)  So in that case, all the ingredients that are NA for `part` go with the cake.

- Some don't have frosting or toppings, and all the ingredients are for the cake (e.g. 235291, 239265).

- Others list all the ingredients for the frosting and cake in one list (e.g. 245175, 218356).

- Yet others are complete bullshit and have "cupcakes" as one of the ingredients (261787)

So far I've dealt with this by assuming if a recipe has any parts, and some ingredients have no associated part, then they are for the cake.  (see code chunk 7: fill-in-parts).

2. **Weird ingredients with non-standard units**

Some recipes include ingredients that are in units of counts, like "24 blueberries".  Alsmost always these are weird toppings, so they might not be a problem if I deal with problem #1.  However, the "other" category is going to be difficult to be standardize regardless.  It might be better to deal with this like a count variable? Like, how many "others" are there?  This should be relatively easy to take care of in the summarise step I think?
