---
title: "R Notebook"
output: html_notebook
author: "Eric R. Scott"
---

```{r packages, message=FALSE, warning=FALSE}
library(rvest)
library(purrr)
library(stringr)
library(tidyverse)
library(beepr) #for notification sounds when long functions are done running
```

To Do:

- add a save_rds at some point to prevent having to re-run read_html_slow() so often 
- milk chocolate gets tagged as "milk" (e.g. 231057).  Add to `case_when()` call to catch chocolate.
- apple butter gets tagged as "fat" (e.g. 255405)
- Convert units so they're all the same
- summarize by ingredient type so all the fats (eg) get added up


```{r helpers}
#create function to read_html slowly to avoid getting banned
read_html_slow <- function(x, ...){
  output <- read_html(x)
  Sys.sleep(5)
  return(output)
}
#testing:
#read_html_slow("http://allrecipes.com/recipe/233538/really-real-strawberry-cupcakes/")
```


# Get links to all cupcake recipes
allrecipes.com has a tag structure that is easy to navigate.  All the recipes for a category show up, but on several pages.  I didn't bother figuring out how many pages there were programatically, I just looked on the website.
```{r}
#initialize vector
cupcakes_urls <- c()

#This link takes you to page 1 by default
base_url <- "http://allrecipes.com/recipes/377/desserts/cakes/cupcakes/"

for(i in 1:12){ #tested and found there are 12 pages of cupcake recipes
  cupcakes_urls <- c(cupcakes_urls, paste0(base_url, "?page=", i))
}

# map the read_html function to read all the pages at once
cupcakes <- map(cupcakes_urls, read_html_slow)
beep(4)

# extract the recipe links from all the pages
results <- cupcakes %>% map(~html_nodes(.,".fixed-recipe-card__title-link"))
cupcakes_links <- results %>% map(~html_attr(.,"href")) %>% flatten_chr()

# remove NAs
cupcakes_links <- cupcakes_links[!is.na(cupcakes_links)]
head(cupcakes_links)
```
Sweet! (literally) Now we have `r length(cupcakes_links)` cupcake recipes.  Let's randomly sample a few to see how easy it is to scrape the actual ingredients list

```{r}
#get random sample of n cupcake recipe links
n = 10
cupcakes_sample <- sample(cupcakes_links, n)
```

# Scrape recipes!
To figure out if cupcakes are different than muffins, I need to get all the ingredients, categorize them as variables, get all the units the same for each variable across recipes, and exclude frosting or toppings. (I only care if the cake part is different from a muffin, obviously cupcakes are frosted and muffins are not).  I should standardize ingredient amounts by serving size.  Serving size and calorie count are in the same spot in each recipe, so I might as well get those too.

## Read in all the html of all the cupcake recipes
```{r read-recipes}
cupcakes_html <- cupcakes_sample %>% map(read_html_slow)
beep(4)
```

## Extract ingredients and categorize into "parts"
Most recipes divide the ingredients list with headers that end in a colon, like "Cake:" or "Frosting:".  I can use that to create a variable, `part`, that later will help me filter out toppings and frostings.
```{r extract-parts}
cupcakes_ing <- cupcakes_html %>% map(~html_nodes(., ".added")) %>% map(html_text)

cupcakes_ing <- cupcakes_ing %>% map(~ as_tibble(.) %>%
                       mutate(part = str_extract(.$value, ".+:$")) %>% 
                       fill(part) %>% 
                       filter(!str_detect(.$value, ":")) %>% 
                       filter(value != "Add all ingredients to list"))
```
*What if there are no "parts"?* I think it is safe to assume that if a recipe has a "part" for some ingredients but not for others, the ones without a "part" are the cake.  If a recipe has no "parts" listed at all, then it should be excluded as it is not safe to assume all ingredients are for the cake (see "problems" below for examples and more discussion).

```{r fill-in-parts}
cupcakes_ing <- cupcakes_ing %>% map(~
  mutate(., part = ifelse(any(!is.na(part)) & is.na(part), "Cake:", part)))
```


## Extract calories and serving size
```{r}
calories <- cupcakes_html %>% 
  map(~html_nodes(., ".calorie-count span:nth-child(1)")) %>%
  map(html_text)

servings <- cupcakes_html %>% 
  map(~html_nodes(., ".subtext")) %>%
  map(html_text) %>% 
  map(~str_extract(.,"(?<=yields\\s)\\d+"))

cupcakes_ing <- map2(cupcakes_ing, servings, ~mutate(.x, servings = as.integer(.y)))
cupcakes_ing <- map2(cupcakes_ing, calories, ~mutate(.x, calories = as.integer(.y)))
```


# Flatten
Extract recipe ID number and `bind_rows()` to create one data frame for all recipes in `cupcake_sample`

```{r}
#add names to list of data frames
names(cupcakes_ing) <- str_extract(cupcakes_sample, "(?<=/)\\d+")

cupcakes_ing <- cupcakes_ing %>% bind_rows(.id = "Recipe ID")
```


# Extract variables
I'll use regular expressions to try to extract the amount and units.  Then in the same `mutate()` call I'll try to categorize ingredients into discrete variables.

```{r}
cupcakes_ing2 <- cupcakes_ing %>%  
  mutate(value = tolower(value)) %>% 
  mutate(amount = str_extract(.$value, "^[\\d, /]+"),
         units = str_extract(.$value, "(\\(.+\\)|[^0-9, /]+)"), #finds either something in parens, or next word
         ingredient = case_when(str_detect(.$value, "sugar")        ~ "sugar",
                                str_detect(.$value, "honey")        ~ "sugar",
                                str_detect(.$value, "agave")        ~ "sugar",
                                str_detect(.$value, "flour")        ~ "flour",
                                str_detect(.$value, "egg")          ~ "eggs",
                                str_detect(.$value, "baking")       ~ "leavening",
                                str_detect(.$value, "\\boil\\b")    ~ "fat",
                                str_detect(.$value, "butter")       ~ "fat",
                                str_detect(.$value, "shortening")   ~ "fat",
                                str_detect(.$value, "cream cheese") ~ "other dairy",
                                str_detect(.$value, "sour cream")   ~ "other dairy",
                                str_detect(.$value, "milk")         ~ "milk",
                                str_detect(.$value, "tartar")       ~ "other",
                                str_detect(.$value, "cream")        ~ "milk",
                                str_detect(.$value, "salt")         ~ "salt",
                                str_detect(.$value, "yogurt")       ~ "other dairy",
                                str_detect(.$value, "water")        ~ "water",
                                str_detect(.$value, "vanilla")      ~ "vanilla",
                                TRUE ~ "other"))

# test <- cupcakes_ing[[1]]$value
# str_view(test, "^[\\d, /]+")
# str_view(test, "([^0-9, /]+|\\(.+\\))")
# str_view(test, "(\\(.+\\)|[^0-9, /]+)")
# str_view(test, "[^0-9, /, \\(]+")

cupcakes_ing2
```

After testing this with several different random samples of cupcake recipes, I'm pretty happy with it. 

# Convert fractions to decimals
The `ammount` column is character class.  I want numeric.

I think one approach would be to turn a space into a "+" then use mutate to do `eval(parse(ammount))`
```{r}
cupcakes_ing3 <- cupcakes_ing2 %>% 
  mutate(amount = str_trim(amount)) %>% 
  mutate(dec_amount = str_replace(amount, "\\s", "+")) %>% 
  mutate(dec_amount = sapply(dec_amount, function(x) eval(parse(text=x))))
cupcakes_ing3 %>% select(amount, dec_amount, everything())
```

# Unit conversions

## Deal with package size
Occasionally an ingredient is like "1 (8 ounce) packet of cream cheese" and my script so far detects "1" as the amount and "(8 ounce)" as the units.  I should deal with this.

**Deal with "oz." and possible decimal points (e.g. "12.5 ounce")** (e.g. 234135)
```{r}
#test <- cupcakes_ing3$units
#str_view_all(test, "\\(.+ (ounce|oz.)")

#test2 <- c("(8 ounce)", "(.68 oz. tube)", "(12.3 ounce)")
#str_view(test2, "\\.?\\d+\\.?\\d*")

# as.numeric(str_extract(test, "\\d+"))*1
cupcakes_ing3 <- cupcakes_ing3 %>%
  mutate(dec_amount = ifelse(str_detect(units, "\\(.+ (ounce|oz.)"),
                          as.numeric(str_extract(units, "\\.?\\d+\\.?\\d*")) * dec_amount,
                          dec_amount),
         units = ifelse(str_detect(units, "\\(.+ (ounce|oz.)"), "ounces", units))
```

```{r}
#overwrite original amount column to avoid confusion
cupcakes_ing4 <- cupcakes_ing3 %>%
  select(-amount) %>%
  rename(amount = dec_amount) %>% 
  select(`Recipe ID`, ingredient, amount, units, part, servings, calories, value)
```

## Unit conversions
```{r}
#things that should be in cups
cups <- c("flour", "sugar", "fat", "milk", "other dairy", "water", "other")
#things that should be in tablespoons
tbsp <- c("salt", "leavening", "vanilla")

cupcakes_ing4 %>% 
  mutate(units_std = case_when(ingredient %in% cups ~ "cups",
                               ingredient == "eggs" ~ "eggs",
                               ingredient %in% tbsp ~ "tablespoons")) %>% 
  mutate(amount_std = case_when(ingredient %in% cups & str_detect(units, "cup")        ~ amount,
                                ingredient %in% cups & str_detect(units, "teaspoon")   ~ amount * 0.0208333,
                                ingredient %in% cups & str_detect(units, "tablespoon") ~ amount * 0.0625,
                                ingredient %in% cups & str_detect(units, "ounce")      ~ amount * 0.125,
                                ingredient %in% cups & str_detect(units, "pint")       ~ amount * 2,
                                ingredient == "eggs"                                   ~ amount,
                                ingredient %in% tbsp & str_detect(units, "tablespoon") ~ amount,
                                ingredient %in% tbsp & str_detect(units, "teaspoon")   ~ amount * 1/3,
                                ingredient %in% tbsp & str_detect(units, "cup")        ~ amount * 16,
                                TRUE                                                   ~ as.numeric(NA))) %>% 
  select(`Recipe ID`, ingredient, amount, units, amount_std, units_std, everything())

```




# Dealing with inconsistencies between recipes

Problems:

1. **Recipes without defined "parts"**

Some recipes don't define what ingredients are for the cakes vs. the frosting.  My intention is to exclude frosting ingredients from this analysis, so the safest way to deal with this is to assume that unless it has the word "cake" somewhere in the `part` column, then the ingredient is not for the cake part.

- Some have a "part" for frosting, but not for the cake. (e.g. 261244, 255301)  So in that case, all the ingredients that are NA for `part` go with the cake.

- Some don't have frosting or toppings, and all the ingredients are for the cake (e.g. 235291, 239265).

- Others list all the ingredients for the frosting and cake in one list (e.g. 245175, 218356).

- Yet others are complete bullshit and have "cupcakes" as one of the ingredients (261787)

So far I've dealt with this by assuming if a recipe has any parts, and some ingredients have no associated part, then they are for the cake.  (see code chunk 7: fill-in-parts).

2. **Weird ingredients with non-standard units**

Some recipes include ingredients that are in units of counts, like "24 blueberries".  Alsmost always these are weird toppings, so they might not be a problem if I deal with problem #1.  However, the "other" category is going to be difficult to be standardize regardless.  It might be better to deal with this like a count variable? Like, how many "others" are there?
